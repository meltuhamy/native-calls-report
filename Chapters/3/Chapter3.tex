\chapter{Project \& Evaluation Plan} 

\label{Chapter3} 
\lhead{Chapter 3. \emph{Project \& Evaluation Plan}} 
% 	You should explain what needs to be done in order to complete the project and roughly what you expect the timetable to be. Don’t forget to include the project write-up, as this is a major part of the exercise. It’s important to identify key milestones and also fall-back positions, in case you run out of time.  You should also identify what extensions could be added if time permits.  The plan should be complete and should include those parts that you have already addressed (make it clear how far you have progressed at the time of writing).  This material will not appear in the final report.



\section{Project Key milestones}
\begin{description}
	\item[Implement NaClRPCGen] 
	~\\
	This is the main deliverable of the project. It will generate JavaScript and C++ header files using an input IDL file. These will be the stubs. This will consist of:
	\begin{itemize}
		\item Choosing a WebIDL parser. I will need to try out the existing parsers I have found and discussed in the WebIDL section of the background. Most likely, I will need to implement my own NaCl compatible WebIDL bindings, but I could definitely find inspiration from the C++ bindings. The JavaScript bindings are most likely going to be straight forward, but I will need to modify them so that they can call the library methods that will do the communications.
		\item Use the parser to create NaCl C++ bindings, and create JavaScript stub headers.
		\item Research and try out different message formats (some of which I have enumerated in the background). Find out what could be the best format to use. Perhaps some of them are useful for RPC over a network, where the main latency is the transferring of bytes, rather than format conversion.
		\item Most likely I will implement JSON-RPC just for simplicity. This could be a fallback.
	\end{itemize}
	\item[Implement the `RPCRuntime'] 
	~\\
	This will need to be done in both JavaScript and Native Client. This will be implemented on top of the message passing framework that already exists.
	\item[Give a working example]
	~\\
	Write an application that uses these tools, and show a typical development environment/cycle.
	\item[Write up] 
	~\\
	Complete the writeup to show how my RPC framework works, including the architecture and tools used. Give justification for each tool used, noting other alternatives I could have used.
\end{description}

\section{Implementation status \& plan}
Here is a preliminary timeline:

\begin{description}
	\item[February]
	~\\
	WebIDL parser should be ready, including deciding on JavaSript bindings and C++ bindings that I should base it on. A full system design should be made, which should explain the architecture of the RPC system. This should include the evaluation of different protocols and message formats.

	\item[March]
	~\\
	Parser should be developed and used to generate stubs. A first implementation of generating stubs (NaClRPCGen) should be done, and this should be a simple subset of the types supported by WebIDL. C++ header files and JavaScript functions should be automatically generated here. A first implementation of the RPCRuntime libraries should be started, and should allow basic remote procedure calls to the NaCl module.

	\item[April]
	~\\
	Iterative improvement of the parser, NaClRPCGen, and the RPCRuntime libraries. This should implement more and more types, and improve the RPC call framework. I should be able to use the RPC framework with different applications that already exist, such as bullet.

	\item[May and June]
	~\\
	Finish off implementation and complete the report, including evaluating the system (see Evaluation Plan). 

\end{description}

At the time of writing, none of these things have been implemented, as I spent time to research ideas and think of this plan. I plan to do a simple implementation this term that will include a parser and stub generator for very basic JavaScript and C++ types, e.g. just numbers. This exercise should help me understand how difficult it would be to do it for all types, and it would probably expose some areas I should think about in my architecture and implementation. I could come up with an incremental approach to implement the full product. This would ensure that even if the project is not completed by the deadline, I will at least have it working for \emph{some} types of programs.

\section{Evaluation Plan}
I think evaluation my project will include two types of evaluation, one quantitative and one qualitative.

The quantitative part includes measuring how much overhead the RPC framework adds to the simple message passing approach. I will need to measure this for different types of applications: e.g. applications which need to continuously call RPC functions might behave differently to applications which call them every once in a while.

The qualitative evaluation includes seeing how much development time is saved when using RPC. This could be measured by the number of lines the developer needs to write to achieve the same thing with message passing and with RPC.